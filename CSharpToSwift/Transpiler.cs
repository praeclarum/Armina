namespace CSharpToSwift;

using System;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.MSBuild;

class Transpiler
{
    readonly string projectFilePath;
    readonly string swiftPackageName;
    readonly string swiftPackageDir;
    readonly string sourcesDir;
    readonly MSBuildWorkspace workspace = MSBuildWorkspace.Create();
    public Transpiler(string projectFilePath)
    {
        this.projectFilePath = Path.GetFullPath(projectFilePath);
        this.swiftPackageName = Path.GetFileNameWithoutExtension(projectFilePath);
        this.swiftPackageDir = Path.Combine("/Users/fak/Work/CSharpToSwift", swiftPackageName);
        this.sourcesDir = Path.Combine(swiftPackageDir, "Sources", swiftPackageName);
    }
    static Transpiler()
    {
        Microsoft.Build.Locator.MSBuildLocator.RegisterDefaults();
        var _ = typeof(Microsoft.CodeAnalysis.CSharp.Formatting.CSharpFormattingOptions);
    }
    readonly Dictionary<string, int> errorCounts = new Dictionary<string, int> ();
    void Error(string message)
    {
        if (!errorCounts.ContainsKey(message))
            errorCounts[message] = 0;
        errorCounts[message]++; 
    }
    void Info(string message)
    {
        Console.ForegroundColor = ConsoleColor.Green;
        Console.WriteLine(message);
        Console.ResetColor();
    }
    
    public async Task TranspileAsync()
    {
        Directory.CreateDirectory(sourcesDir);
        var projectFileName = Path.GetFileName(projectFilePath);
        Info($"Loading project {projectFileName}...");
        var project = await workspace.OpenProjectAsync(projectFilePath);
        var projectLoadErrors = workspace.Diagnostics.Where(x => x.Kind == WorkspaceDiagnosticKind.Failure);
        foreach (var d in projectLoadErrors) {
            Error(d.Message);
        }
        if (projectLoadErrors.Any()) {
            return;
        }
        Info($"Analyzing project {project.Name}...");
        var compilation = await project.GetCompilationAsync();
        if (compilation is null) {
            Error("Failed to get compilation");
            return;
        }
        if (compilation.GetDiagnostics().Any(x => x.Severity == DiagnosticSeverity.Error)) {
            foreach (var d in compilation.GetDiagnostics()) {
                Error(d.ToString());
            }
            return;
        }
        
        Info($"Transpiling...");
        var types = new List<(MemberDeclarationSyntax Syntax, SemanticModel Model)>();
        await GetTypeDeclarationsAsync (compilation, types);

        // var outputDir = System.IO.Path.GetDirectoryName(projectFilePath);
        TextWriter NewSwiftWriter(string swiftName) {
            var fileName = $"{swiftName}.swift";
            var filePath = System.IO.Path.Combine(sourcesDir, fileName);
            return new System.IO.StreamWriter(filePath);
        }
        using (var pw = new StreamWriter(Path.Combine(swiftPackageDir, "Package.swift"))) {
            pw.WriteLine($"// swift-tools-version: 5.6");
            pw.WriteLine();
            pw.WriteLine($"import PackageDescription");
            pw.WriteLine();
            pw.WriteLine($"let package = Package(");
            pw.WriteLine($"    name: \"{swiftPackageName}\",");
            pw.WriteLine($"    products: [");
            pw.WriteLine($"        .library(name: \"{swiftPackageName}\",");
            pw.WriteLine($"                 targets: [\"{swiftPackageName}\"])");
            pw.WriteLine($"    ],");
            pw.WriteLine($"    dependencies: [");
            pw.WriteLine($"    ],");
            pw.WriteLine($"    targets: [");
            pw.WriteLine($"        .target(name: \"{swiftPackageName}\",");
            pw.WriteLine($"                dependencies: []),");
            pw.WriteLine($"    ]");
            pw.WriteLine($")");
        }
        var swift = new StringWriter();
        swift.WriteLine("// This file was generated by CSharpToSwift");
        foreach (var (node, model) in types) {
            var symbol = (INamedTypeSymbol)model.GetDeclaredSymbol(node)!;
            var swiftName = GetSwiftTypeName(symbol);
            switch (node.Kind ()) {
                case SyntaxKind.ClassDeclaration:
                    var c = (ClassDeclarationSyntax)node;
                    using (var cw = NewSwiftWriter(swiftName)) {
                        TranspileClass(swiftName, c, symbol, model, cw);
                    }
                    break;
                case SyntaxKind.StructDeclaration:
                    var s = (StructDeclarationSyntax)node;
                    using (var sw = NewSwiftWriter(swiftName)) {
                        TranspileStruct(swiftName, s, symbol, model, sw);
                    }
                    break;
                default:
                    Error($"Unsupported type kind: {node.Kind()}");
                    break;
            }
        }
        // Show errors sorted by count
        var totalErrors = 0;
        foreach (var kvp in errorCounts.OrderBy(x => x.Value)) {
            var count = kvp.Value;
            totalErrors += count;
            Console.ForegroundColor = ConsoleColor.Red;
            Console.Write($"Error:");
            Console.ResetColor();
            Console.WriteLine($" {kvp.Key} ({count}x)");
        }
        if (totalErrors > 0) {
            Console.ForegroundColor = ConsoleColor.Red;
            Console.WriteLine($"{totalErrors} errors");
            Console.ResetColor();
        }
        else {
            Console.ForegroundColor = ConsoleColor.Green;
            Console.WriteLine("OK");
            Console.ResetColor();
        }
    }

    void TranspileClass(string swiftName, ClassDeclarationSyntax node, INamedTypeSymbol symbol, SemanticModel model, TextWriter w)
    {
        w.Write($"class {swiftName}");
        var head = " : ";
        if (symbol.BaseType is {} baseType && !(baseType.Name == "Object" && baseType.ContainingNamespace.Name == "System")) {
            var baseSwiftName = GetSwiftTypeName(baseType);
            w.Write($"{head}{baseSwiftName}");
            head = ", ";
        }
        foreach (var i in symbol.Interfaces) {
            var baseSwiftName = GetSwiftTypeName(i);
            w.Write($"{head}{baseSwiftName}");
            head = ", ";
        }
        w.WriteLine($" {{");
        foreach (var member in node.Members) {
            TranspileClassOrStructMember(member, swiftName, node, symbol, model, w);
        }
        w.WriteLine($"}}");
    }

    void TranspileStruct(string swiftName, StructDeclarationSyntax node, INamedTypeSymbol symbol, SemanticModel model, TextWriter w)
    {
        w.Write($"struct {swiftName}");
        var head = " : ";
        foreach (var i in symbol.Interfaces) {
            var baseSwiftName = GetSwiftTypeName(i);
            w.Write($"{head}{baseSwiftName}");
            head = ", ";
        }
        w.WriteLine($" {{");
        foreach (var member in node.Members) {
            TranspileClassOrStructMember(member, swiftName, node, symbol, model, w);
        }
        w.WriteLine($"}}");
    }

    void TranspileClassOrStructMember(MemberDeclarationSyntax member, string typeName, TypeDeclarationSyntax node, INamedTypeSymbol typeSymbol, SemanticModel model, TextWriter w)
    {
        switch (member.Kind ()) {
            case SyntaxKind.ConstructorDeclaration:
                TranspileCtor((ConstructorDeclarationSyntax)member, typeSymbol, model, w);
                break;
            case SyntaxKind.FieldDeclaration:
                TranspileField((FieldDeclarationSyntax)member, typeSymbol, model, w);
                break;
            case SyntaxKind.MethodDeclaration:
                TranspileMethod((MethodDeclarationSyntax)member, typeSymbol, model, w);
                break;
            case SyntaxKind.PropertyDeclaration:
                TranspileProperty((PropertyDeclarationSyntax)member, typeSymbol, model, w);
                break;
            // case SyntaxKind.EventDeclaration:
            //     var evt = (EventDeclarationSyntax)member;
            //     TranspileEvent(evt, symbol, w);
            //     break;
            // case SyntaxKind.IndexerDeclaration:
            //     var idx = (IndexerDeclarationSyntax)member;
            //     TranspileIndexer(idx, symbol, w);
            //     break;
            // case SyntaxKind.EventFieldDeclaration:
            //     var evtField = (EventFieldDeclarationSyntax)member;
            //     TranspileEventField(evtField, symbol, w);
            //     break;
            // case SyntaxKind.ConstantFieldDeclaration:
            //     var constField = (ConstantFieldDeclarationSyntax)member;
            //     TranspileConstantField(constField, symbol, w);
            //     break;
            // case SyntaxKind.EnumMemberDeclaration:
            //     var enumMember = (EnumMemberDeclarationSyntax)member;
            //     TranspileEnumMember(enumMember, symbol, w);
            //     break;
            // case SyntaxKind.EventAccessorDeclaration:
            //     var evtAccessor = (EventAccessorDeclarationSyntax)member;
            //     TranspileEventAccessor(evtAccessor, symbol, w);
            //     break;
            default:
                Error($"Unsupported member kind: {member.Kind()}");
                break;
        }
    }

    void TranspileField(FieldDeclarationSyntax field, INamedTypeSymbol containerTypeSymbol, SemanticModel model, TextWriter w)
    {
        var docs = GetDocs(field);
        var type = model.GetSymbolInfo(field.Declaration.Type).Symbol;
        
        var ftypeName = GetSwiftTypeName(type);
        var isReadOnly = field.Modifiers.Any(x => x.IsKind(SyntaxKind.ReadOnlyKeyword));
        var isStatic = field.Modifiers.Any(x => x.IsKind(SyntaxKind.StaticKeyword));
        var decl = isReadOnly ? (isStatic ? "static let" : "let") : (isStatic ? "static var" : "var");
        
        foreach (var v in field.Declaration.Variables)
        {
            var fieldSymbol = model.GetDeclaredSymbol(v);
            var acc = GetAccessLevelModifier(fieldSymbol);
            var vn = v.Identifier.ToString();
            var init = TranspileExpression(v.Initializer?.Value, model);
            if (!isReadOnly)
                init = GetDefaultValue(type);
            var typeSuffix = init == "nil" ? "?" : "";
            if (init is not null)
                init = " = " + init;
            if (docs.Length > 0)
                w.WriteLine($"    /// {docs}");
            w.WriteLine($"    {acc}{decl} {vn}: {ftypeName}{typeSuffix}{init}");
        }
    }

    void TranspileCtor(ConstructorDeclarationSyntax ctor, INamedTypeSymbol containerTypeSymbol, SemanticModel model, TextWriter w)
    {
        var docs = GetDocs(ctor);
        if (docs.Length > 0)
            w.WriteLine($"    /// {docs}");
        var methodSymbol = model.GetDeclaredSymbol(ctor);
        var acc = GetAccessLevelModifier(methodSymbol);
        var isStatic = ctor.Modifiers.Any(x => x.IsKind(SyntaxKind.StaticKeyword));
        var slotType = isStatic ? "static " : "";
        w.Write($"    {acc}{slotType}init(");
        TranspileParams(ctor.ParameterList, model, w);
        w.WriteLine($") {{");
        if (ctor.Body is {} block) {
            TranspileBlock(block, model, "        ", w);
        }
        w.WriteLine($"    }}");
    }

    void TranspileMethod(MethodDeclarationSyntax method, INamedTypeSymbol containerTypeSymbol, SemanticModel model, TextWriter w)
    {
        var docs = GetDocs(method);
        if (docs.Length > 0)
            w.WriteLine($"    /// {docs}");
        var returnType = model.GetSymbolInfo(method.ReturnType).Symbol;
        var isVoid = IsTypeVoid(returnType);
        var returnTypeCode = isVoid ? "" : $" -> {GetSwiftTypeName(returnType)}";
        var methodSymbol = model.GetDeclaredSymbol(method);
        var acc = GetAccessLevelModifier(methodSymbol);
        var isStatic = method.Modifiers.Any(x => x.IsKind(SyntaxKind.StaticKeyword));
        var isOverride = method.Modifiers.Any(x => x.IsKind(SyntaxKind.OverrideKeyword));
        var isSealed = method.Modifiers.Any(x => x.IsKind(SyntaxKind.SealedKeyword));
        var isAbstract = method.Modifiers.Any(x => x.IsKind(SyntaxKind.AbstractKeyword));
        var isVirtual = method.Modifiers.Any(x => x.IsKind(SyntaxKind.VirtualKeyword));
        if (isAbstract)
        {
            Error("Abstract methods are not supported");
        }
        // acc = acc + $"/*{method.Modifiers}*/";
        var slotType = isStatic ? "static " : (isOverride ? "override " : (isAbstract ? "/*abstract*/ " : (isVirtual ? "" : "final ")));
        w.Write($"    {acc}{slotType}func {method.Identifier.ToString()}(");
        TranspileParams(method.ParameterList, model, w);
        w.WriteLine($"){returnTypeCode} {{");
        if (method.Body is {} block) {
            TranspileBlock(block, model, "        ", w);
        }
        w.WriteLine($"    }}");
    }

    private void TranspileParams(ParameterListSyntax parameterList, SemanticModel model, TextWriter w)
    {
        var head = "";
        foreach (var p in parameterList.Parameters)
        {
            var ptypeSymbol = model.GetSymbolInfo(p.Type).Symbol;
            var ptypeName = GetSwiftTypeName(ptypeSymbol);
            var pname = p.Identifier.ToString();
            w.Write($"{head}{pname}: {ptypeName}");
            head = ", ";
        }
    }

    void TranspileProperty(PropertyDeclarationSyntax prop, INamedTypeSymbol containerTypeSymbol, SemanticModel model, TextWriter w)
    {
        var docs = GetDocs(prop);
        if (docs.Length > 0)
            w.WriteLine($"    /// {docs}");
        var returnType = model.GetSymbolInfo(prop.Type).Symbol;
        string slotType = GetSlotTypeModifier(prop);
        var vn = prop.Identifier.ToString();
        var init = TranspileExpression(prop.Initializer?.Value, model);
        if (init is not null)
            init = " = " + init;
        w.WriteLine($"    {slotType}var {vn}: {GetSwiftTypeName(returnType)}{init} {{");
        if (prop.AccessorList is { } alist)
        {
            foreach (var accessor in alist.Accessors)
            {
                var accLevel = GetAccessLevelModifier(accessor, model);
                w.WriteLine($"        {accessor.Keyword} {{");
                if (accessor.Body is {} block) {
                    TranspileBlock(block, model, "            ", w);
                }
                w.WriteLine($"        }}");
            }
        }
        w.WriteLine($"    }}");
    }

    string? TranspileExpression(ExpressionSyntax? value, SemanticModel model)
    {
        if (value is null) {
            return null;
        }
        switch (value.Kind ()) {
            case SyntaxKind.AddExpression:
                var add = (BinaryExpressionSyntax)value;
                return $"{TranspileExpression(add.Left, model)} + {TranspileExpression(add.Right, model)}";
            case SyntaxKind.BaseExpression:
                return "super";
            case SyntaxKind.CastExpression:
                var cast = (CastExpressionSyntax)value;
                return $"{TranspileExpression(cast.Expression, model)} as {GetSwiftTypeName (cast.Type, model)}";
            case SyntaxKind.DivideExpression:
                var div = (BinaryExpressionSyntax)value;
                return $"{TranspileExpression(div.Left, model)} / {TranspileExpression(div.Right, model)}";
            case SyntaxKind.ElementAccessExpression:
                var ea = (ElementAccessExpressionSyntax)value;
                var eaArgs = string.Join(", ", ea.ArgumentList.Arguments.Select(x => TranspileExpression(x.Expression, model)));
                return $"{TranspileExpression(ea.Expression, model)}[{eaArgs}]";
            case SyntaxKind.EqualsExpression:
                var eq = (BinaryExpressionSyntax)value;
                return $"{TranspileExpression(eq.Left, model)} == {TranspileExpression(eq.Right, model)}";
            case SyntaxKind.FalseLiteralExpression:
                return "false";
            case SyntaxKind.GreaterThanExpression:
                var gt = (BinaryExpressionSyntax)value;
                return $"{TranspileExpression(gt.Left, model)} > {TranspileExpression(gt.Right, model)}";
            case SyntaxKind.GreaterThanOrEqualExpression:
                var gte = (BinaryExpressionSyntax)value;
                return $"{TranspileExpression(gte.Left, model)} >= {TranspileExpression(gte.Right, model)}";
            case SyntaxKind.IdentifierName:
                var id = (IdentifierNameSyntax)value;
                return id.Identifier.ToString();
            case SyntaxKind.InvocationExpression:
                var inv = (InvocationExpressionSyntax)value;
                var args = inv.ArgumentList.Arguments.Select(a => TranspileExpression(a.Expression, model)).ToArray();
                return $"{TranspileExpression(inv.Expression, model)}({string.Join(", ", args)})";
            case SyntaxKind.LessThanExpression:
                var lt = (BinaryExpressionSyntax)value;
                return $"{TranspileExpression(lt.Left, model)} < {TranspileExpression(lt.Right, model)}";
            case SyntaxKind.LessThanOrEqualExpression:
                var lte = (BinaryExpressionSyntax)value;
                return $"{TranspileExpression(lte.Left, model)} <= {TranspileExpression(lte.Right, model)}";
            case SyntaxKind.LogicalAndExpression:
                var and = (BinaryExpressionSyntax)value;
                return $"{TranspileExpression(and.Left, model)} && {TranspileExpression(and.Right, model)}";
            case SyntaxKind.LogicalNotExpression:
                var not = (PrefixUnaryExpressionSyntax)value;
                return $"!{TranspileExpression(not.Operand, model)}";
            case SyntaxKind.LogicalOrExpression:
                var or = (BinaryExpressionSyntax)value;
                return $"{TranspileExpression(or.Left, model)} || {TranspileExpression(or.Right, model)}";
            case SyntaxKind.MultiplyExpression:
                var mul = (BinaryExpressionSyntax)value;
                return $"{TranspileExpression(mul.Left, model)} * {TranspileExpression(mul.Right, model)}";
            case SyntaxKind.NotEqualsExpression:
                var neq = (BinaryExpressionSyntax)value;
                return $"{TranspileExpression(neq.Left, model)} != {TranspileExpression(neq.Right, model)}";
            case SyntaxKind.NullLiteralExpression:
                return "nil";
            case SyntaxKind.NumericLiteralExpression:
                var nlit = (LiteralExpressionSyntax)value;
                {
                    var ntext = nlit.Token.Text;
                    if (ntext[0] == '.')
                        ntext = "0" + ntext;
                    return ntext;
                }
            case SyntaxKind.ParenthesizedExpression:
                var paren = (ParenthesizedExpressionSyntax)value;
                return $"({TranspileExpression(paren.Expression, model)})";
            case SyntaxKind.SimpleAssignmentExpression:
                var sae = (AssignmentExpressionSyntax)value;
                return $"{TranspileExpression(sae.Left, model)} = {TranspileExpression(sae.Right, model)}";
            case SyntaxKind.SimpleMemberAccessExpression:
                var sma = (MemberAccessExpressionSyntax)value;
                return $"{TranspileExpression(sma.Expression, model)}.{sma.Name.ToString()}";
            case SyntaxKind.StringLiteralExpression:
                var slit = (LiteralExpressionSyntax)value;
                {
                    var stext = slit.GetText().ToString();
                    if (stext.Length > 0 && stext[0] == '@') {
                        stext = "\"\"\"\n" + slit.Token.ValueText + "\n\"\"\"";
                    }
                    return stext;
                }
            case SyntaxKind.SubtractExpression:
                var sub = (BinaryExpressionSyntax)value;
                return $"{TranspileExpression(sub.Left, model)} - {TranspileExpression(sub.Right, model)}";
            case SyntaxKind.ThisExpression:
                return "self";
            case SyntaxKind.TrueLiteralExpression:
                return "true";
            case SyntaxKind.UnaryMinusExpression:
                var ume = (PrefixUnaryExpressionSyntax)value;
                return $"-{TranspileExpression(ume.Operand, model)}";
            default:
                Error($"Unsupported expression kind: {value.Kind()}");
                return $"nil/*{value.Kind()}: {value.ToString().Trim()}*/";
        }
    }

    void TranspileBlock(BlockSyntax block, SemanticModel model, string indent, TextWriter w)
    {
        foreach (var stmt in block.Statements)
        {
            TranspileStatement(stmt, model, indent, w);
        }
    }

    void TranspileStatement(StatementSyntax stmt, SemanticModel model, string indent, TextWriter w)
    {
        switch (stmt.Kind()) {
            case SyntaxKind.Block:
                TranspileBlock((BlockSyntax)stmt, model, indent, w);
                break;
            case SyntaxKind.ExpressionStatement:
                TranspileExpressionStatement((ExpressionStatementSyntax)stmt, model, indent, w);
                break;
            case SyntaxKind.IfStatement:
                TranspileIfStatement((IfStatementSyntax)stmt, model, indent, w);
                break;
            case SyntaxKind.LocalDeclarationStatement:
                TranspileLocalDeclarationStatement((LocalDeclarationStatementSyntax)stmt, model, indent, w);
                break;
            case SyntaxKind.ReturnStatement:
                TranspileReturnStatement((ReturnStatementSyntax)stmt, model, indent, w);
                break;
            default:
                Error($"Unsupported statement {stmt.Kind()}");
                w.WriteLine($"{indent}/*{stmt.Kind()}: {stmt.ToString().Trim()}*/");
                break;
        }
    }

    void TranspileExpressionStatement(ExpressionStatementSyntax stmt, SemanticModel model, string indent, TextWriter w)
    {
        var expr = TranspileExpression(stmt.Expression, model);
        w.WriteLine($"{indent}{expr}");
    }

    void TranspileIfStatement(IfStatementSyntax stmt, SemanticModel model, string indent, TextWriter w)
    {
        var cond = TranspileExpression(stmt.Condition, model);
        w.WriteLine($"{indent}if {cond} {{");
        TranspileStatement(stmt.Statement, model, indent + "    ", w);
        if (stmt.Else is { } elseClause)
        {
            w.WriteLine($"{indent}}} else {{");
            TranspileStatement(elseClause.Statement, model, indent + "    ", w);            
        }
        w.WriteLine($"{indent}}}");
    }

    void TranspileLocalDeclarationStatement(LocalDeclarationStatementSyntax stmt, SemanticModel model, string indent, TextWriter w)
    {
        foreach (var v in stmt.Declaration.Variables)
        {
            var vn = v.Identifier.ToString();
            var init = TranspileExpression(v.Initializer?.Value, model);
            if (init is not null)
                init = " = " + init;
            w.WriteLine($"{indent}var {vn}{init}");
        }
    }

    void TranspileReturnStatement(ReturnStatementSyntax stmt, SemanticModel model, string indent, TextWriter w)
    {
        var expr = stmt.Expression;
        if (expr is null)
            w.WriteLine($"{indent}return");
        else
            w.WriteLine($"{indent}return {TranspileExpression(expr, model)}");
    }

    static string GetDocs(CSharpSyntaxNode field)
    {
        var lines =
            field.GetLeadingTrivia()
            .Where(x => x.IsKind(SyntaxKind.MultiLineDocumentationCommentTrivia) || x.IsKind(SyntaxKind.SingleLineDocumentationCommentTrivia))
            .SelectMany(x => x.ToFullString().Split('\n'))
            .Select(x =>
                x
                .Replace("<summary>", "")
                .Replace("</summary>", "")
                .Replace("<b>", "**")
                .Replace("</b>", "**")
                .Replace("///", "")
                .Replace("\t", " ")
                .Trim())
            .Where(x => x.Length > 0);
        return string.Join(" ", lines);
    }

    static string GetSlotTypeModifier(MemberDeclarationSyntax member)
    {
        var isStatic = member.Modifiers.Any(x => x.IsKind(SyntaxKind.StaticKeyword));
        var isOverride = member.Modifiers.Any(x => x.IsKind(SyntaxKind.OverrideKeyword));
        var isSealed = member.Modifiers.Any(x => x.IsKind(SyntaxKind.SealedKeyword));
        var isAbstract = member.Modifiers.Any(x => x.IsKind(SyntaxKind.AbstractKeyword));
        var isVirtual = member.Modifiers.Any(x => x.IsKind(SyntaxKind.VirtualKeyword));
        var slotType = isStatic ? "static " : (isOverride ? "override " : (isAbstract ? "open " : ""));
        return slotType;
    }

    static string GetAccessLevelModifier(CSharpSyntaxNode node, SemanticModel model)
    {
        var memberSymbol = model.GetSymbolInfo(node).Symbol;
        return GetAccessLevelModifier(memberSymbol);
    }

    static string GetAccessLevelModifier(ISymbol? memberSymbol)
    {
        // access-level-modifier: private | fileprivate | internal | public | open
        if (memberSymbol is null)
            return "";
        return memberSymbol.DeclaredAccessibility switch
        {
            Accessibility.Private => "private ",
            Accessibility.Protected => "",
            Accessibility.Internal => "internal ",
            Accessibility.Public => "",
            _ => "",
        };
    }

    string GetSwiftTypeName(CSharpSyntaxNode type, SemanticModel model)
    {
        var typeSymbol = model.GetSymbolInfo(type).Symbol;
        return GetSwiftTypeName(typeSymbol);
    }

    string GetSwiftTypeName(ISymbol? s)
    {
        if (s == null) {
            return "AnyObject";
        }
        else if (s is IArrayTypeSymbol ats) {
            return $"[{GetSwiftTypeName(ats.ElementType)}]";
        }
        else {
            var name = s.Name;
            switch (name) {
                case nameof(System.Boolean):
                    return "Bool";
                case nameof(System.Byte):
                    return "UInt8";
                case nameof(System.Char):
                    return "Character";
                case nameof(System.IntPtr):
                    return "Int";
                case "Object":
                    return "AnyObject";
                case "Single":
                    return "Float";
                default:
                    if (string.IsNullOrEmpty(name)) {
                        Error($"Symbol {s} : {s.GetType()} has no name");
                        return "AnyObject";
                    }
                    return name;
            }
        }
    }

    bool IsTypeVoid(ISymbol? returnType)
    {
        return returnType is null || (returnType.Name == "Void" && returnType.ContainingNamespace.Name == "System");
    }

    string GetDefaultValue(ISymbol? type)
    {
        if (type == null) {
            return "nil";
        }
        switch (type.Kind) {
            case SymbolKind.ArrayType:
                return "[]";
            case SymbolKind.PointerType:
                return "nil";
            case SymbolKind.DynamicType:
                return "nil";
            case SymbolKind.TypeParameter:
                return "nil";
            case SymbolKind.ErrorType:
                return "nil";
            case SymbolKind.NamedType:
                var ntype = (INamedTypeSymbol)type;
                switch (type.Name) {
                    case nameof(System.Boolean):
                        return "false";
                    case nameof(System.Byte):
                        return "0";
                    case nameof(System.Double):
                        return "0.0";
                    case nameof(System.Single):
                        return "0.0";
                    case nameof(System.Int16):
                        return "0";
                    case nameof(System.Int32):
                        return "0";
                    case nameof(System.Int64):
                        return "0";
                    case nameof(System.IntPtr):
                        return "0";
                    case nameof(System.UInt16):
                        return "0";
                    case nameof(System.UInt32):
                        return "0";
                    case nameof(System.UInt64):
                        return "0";
                    case nameof(System.UIntPtr):
                        return "0";
                    default:
                        if (ntype.IsReferenceType) {
                            return "nil";
                        }
                        else {
                            Error($"Unsupported default value for named type: {type.Name}");
                            return $"0/*NT:{type.Name}*/";
                        }
                }
            default:
                Error($"Unsupported default value for type {type.Kind}");
                return $"nil/*T:{type.Kind}*/";
        }
    }

    async Task GetTypeDeclarationsAsync(Compilation compilation, List<(MemberDeclarationSyntax Syntax, SemanticModel Symbol)> types)
    {
        foreach (var s in compilation.SyntaxTrees.OfType<CSharpSyntaxTree>()) {
            // Info($"Transpiling {s.FilePath}...");
            var m = compilation.GetSemanticModel(s);
            GetTypeDeclarations(await s.GetRootAsync().ConfigureAwait(false), m, compilation, types);
        }
    }

    void GetTypeDeclarations(CSharpSyntaxNode node, SemanticModel model, Compilation compilation, List<(MemberDeclarationSyntax Syntax, SemanticModel Symbol)> types)
    {
        switch (node.Kind ()) {
            case SyntaxKind.ClassDeclaration:
                var c = (ClassDeclarationSyntax)node;
                if (model.GetDeclaredSymbol(c) is INamedTypeSymbol ctype) {
                    // Info($"Found class {ctype.ContainingNamespace}.{ctype.Name}");
                    types.Add((c, model));
                }
                break;
            case SyntaxKind.StructDeclaration:
                var s = (StructDeclarationSyntax)node;
                if (model.GetDeclaredSymbol(s) is INamedTypeSymbol stype) {
                    // Info($"Found struct {stype.ContainingNamespace}.{stype.Name}");
                    types.Add((s, model));
                }
                break;
            case SyntaxKind.InterfaceDeclaration:
                var i = (InterfaceDeclarationSyntax)node;
                if (model.GetDeclaredSymbol(i) is INamedTypeSymbol itype) {
                    // Info($"Found interface {itype.ContainingNamespace}.{itype.Name} {itype.GetType()}");
                    types.Add((i, model));
                }
                break;
            case SyntaxKind.EnumDeclaration:
                var e = (EnumDeclarationSyntax)node;
                if (model.GetDeclaredSymbol(e) is INamedTypeSymbol etype) {
                    // Info($"Found enum {etype.ContainingNamespace}.{etype.Name}");
                    types.Add((e, model));
                }
                break;
            case SyntaxKind.DelegateDeclaration:
                var d = (DelegateDeclarationSyntax)node;
                if (model.GetDeclaredSymbol(d) is INamedTypeSymbol dtype) {
                    // Info($"Found delegate {dtype.ContainingNamespace}.{dtype.Name}");
                    types.Add((d, model));
                }
                break;
            case SyntaxKind.NamespaceDeclaration:
                var n = (NamespaceDeclarationSyntax)node;
                foreach (var m in n.Members) {
                    GetTypeDeclarations(m, model, compilation, types);
                }
                break;
            case SyntaxKind.CompilationUnit:
                var cu = (CompilationUnitSyntax)node;
                foreach (var m in cu.Members) {
                    GetTypeDeclarations(m, model, compilation, types);
                }
                break;
            default:
                break;
        }
    }
}
